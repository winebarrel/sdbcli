#!/usr/bin/env ruby
$LOAD_PATH << File.join(File.expand_path(File.dirname(__FILE__)), '..', 'lib')

Version = '0.4.0'
HISTORY_FILE = File.join((ENV['HOME'] || ENV['USERPROFILE'] || '.'), '.sdbcli_history')
HISTSIZE = 500

require 'rubygems'
require 'sdbcli'

require 'optparse'
require 'readline'
require 'strscan'
require 'syck' if /\A1\.9/ =~ RUBY_VERSION
require 'yaml'
require 'json'

access_key_id     = ENV['AWS_ACCESS_KEY_ID']
secret_access_key = ENV['AWS_SECRET_ACCESS_KEY']
sdb_endpoint      = ENV['SDB_ENDPOINT'] || ENV['REGION_NAME'] || 'sdb.amazonaws.com'
command = nil
$format = :yaml

ARGV.options do |opt|
  opt.on('-k', '--access-key=ACCESS_KEY') {|v| access_key_id = v }
  opt.on('-s', '--secret-key=SECRET_KEY') {|v| secret_access_key = v }
  opt.on('-r', '--region=REGION') {|v| sdb_endpoint = v }
  opt.on('-e', '--eval=COMMAND') {|v| command = v }
  opt.on('-f', '--format=YAML_OR_JSON', [:yaml, :json]) {|v| $format = v }
  opt.parse!

  unless access_key_id and secret_access_key and sdb_endpoint
    puts opt.help
    exit 1
  end
end

$runner = SimpleDB::Runner.new(access_key_id, secret_access_key, sdb_endpoint)

def output_error(msg)
  case $format
  when :yaml
    msg = "# #{msg}\n\n"
  when :json
    msg = "// #{msg}\n\n"
  else
    msg = "# #{msg}\n\n"
  end

  $stderr.puts msg
end

def execute(src, show_rows = false)
  ss = StringScanner.new(src.dup)
  buf = ''

  until ss.eos?
    if (tok = ss.scan %r{[^-`'";\\/#]+})
      buf << tok
    elsif (tok = ss.scan /`(?:[^`]|``)*`/)
      buf << tok
    elsif (tok = ss.scan /'(?:[^']|'')*'/) #'
      buf << tok
    elsif (tok = ss.scan /"(?:[^"]|"")*"/) #"
      buf << tok
    elsif (tok = ss.scan %r{/\*/?(\n|[^/]|[^*]/)*\*/})
      # nothing to do
    elsif (tok = ss.scan /--[^\r\n]*(?:\r\n|\r|\n|\Z)/)
      # nothing to do
    elsif (tok = ss.scan /#[^\r\n]*(?:\r\n|\r|\n|\Z)/)
      # nothing to do
    elsif (tok = ss.scan /(?:;|\\G)/)
      src.replace(ss.rest)
      query = buf
      buf = ''

      if tok == '\G'
        inline = false
      else
        inline = true
      end

      if query.strip.empty?
        output_error('No query specified')
        next
      end

      out = $runner.execute(query, inline)

      if out
        str = nil

        case $format
        when :yaml
          str = YAML.dump(out)
        when :json
          str = JSON.pretty_generate(out)
        else
          output_error('Unknown format')
        end

        str.sub!(/(?:\r\n|\r|\n)*\Z/, "\n")

        if show_rows and out.kind_of?(Array)
          rows_msg = nil

          case $format
          when :yaml
            rows_msg = "# #{out.length} #{out.length > 1 ? 'rows' : 'row'} in set\n"
          when :json
            rows_msg = "// #{out.length} #{out.length > 1 ? 'rows' : 'row'} in set\n"
          else
            rows_msg = "# #{out.length} #{out.length > 1 ? 'rows' : 'row'} in set\n"
          end

          str << rows_msg
        end

        str << "\n"
        puts str
      end
    elsif (tok = ss.scan /./)
      buf << tok
    end
  end

  src.replace(buf.strip)
  buf
end

if not $stdin.tty? or command
  src = command || $stdin.read.strip

  unless src =~ /\s*(?:;|\\G)\Z/i
    src << ';'
  end

  begin
    execute(src)
    exit 0
  rescue => e
    output_error e.message.strip
    exit 1
  end
end

def help
  <<-EOS
# Explanatory notes of a query

SHOW DOMAINS
  displays a domain list

SHOW REGIONS
  displays a region list

CREATE domain domain_name
  creates a domain

DROP DOMAIN domain_name
  deletes a domain

GET [attr_list] FROM domain_name WHERE itemName = '...'
  gets the attribute of an item

INSERT INTO domain_name (itemName, attr1, ...) VALUES ('name', 'val1', ...)
  creates an item

UPDATE domain_name set attr1 = 'val1', ... WHERE itemName = '...'
  updates an item

DELETE [attr1, ...] FROM domain_name WHERE itemName = '...'
  deletes the attribute of an item or an item

SELECT output_list FROM domain_name [WHERE expression] [sort_instructions] [LIMIT limit]
  queries using the SELECT statement
  see http://docs.aws.amazon.com/AmazonSimpleDB/latest/DeveloperGuide/UsingSelect.html

DESC domain_name
  displays information about the domain

USE region_or_endpoint
  changes an endpoint


# List of commands

.help                 displays this message
.quit | .exit         exits sdbcli
.format (yaml|json)?  displays a format or changes it
.version              displays a version

    EOS
end

if File.exist?(HISTORY_FILE)
  open(HISTORY_FILE) do |f|
    f.each_line do |line|
      line = line.strip
      Readline::HISTORY.push(line) unless line.empty?
    end
  end
end

at_exit do
  unless Readline::HISTORY.empty?
    open(HISTORY_FILE, 'wb') do |f|
      (Readline::HISTORY.to_a.slice(-(Readline::HISTORY.length < HISTSIZE ? Readline::HISTORY.length : HISTSIZE)..-1) || []).each do |line|
        next if /\A\s*\Z/ =~ line
        f.puts line
      end
    end
  end
end

src = ''
prompt1 = lambda { "#{$runner.region || 'unknown'}> " }
prompt2 = lambda { "#{' ' * (($runner.region || 'unknown').length - 1)}-> " }
prompt = prompt1.call

while buf = Readline.readline(prompt, true)
  if /\A\s*\Z/ =~ buf
    Readline::HISTORY.pop
    next
  end

  if src.empty? and buf =~ /\A\.(.+)/
    cmd, arg = $1.split(/\s+/i, 2)
    r = /\A#{Regexp.compile(cmd.downcase)}/

    if r =~ 'help'
      puts help
    elsif r =~ 'exit' or r =~ 'quit'
      exit
    elsif r =~ 'format'
      case arg
      when nil
        puts $format
      when 'yaml'
        $format = :yaml
      when 'json'
        $format = :json
      else
        output_error('Unknown format')
      end
    elsif r =~ 'version'
      puts "sdbcli #{Version}"
    else
      output_error('Unknown command')
    end
  else
    rv = nil

    begin
      if src.empty?
        src << buf
      else
        src << ("\n" + buf)
      end

      execute(src, true)
    rescue => e
      output_error e.message.strip
    end

    prompt = src.empty? ? prompt1.call : prompt2.call
  end
end
