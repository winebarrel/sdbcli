#!/usr/bin/env ruby
$LOAD_PATH << File.join(File.expand_path(File.dirname(__FILE__)), '..', 'lib')

Version = '0.2.4'
HISTORY_FILE = File.join((ENV['HOME'] || ENV['USERPROFILE'] || '.'), '.sdbcli_history')

require 'rubygems'
require 'sdbcli'

require 'optparse'
require 'readline'
require 'strscan'
require 'yaml'

access_key_id     = ENV['AWS_ACCESS_KEY_ID']
secret_access_key = ENV['AWS_SECRET_ACCESS_KEY']
sdb_endpoint      = ENV['SDB_ENDPOINT'] || ENV['REGION_NAME'] || 'sdb.amazonaws.com'

if /\A[^.]+\Z/ =~ sdb_endpoint
  sdb_endpoint = "sdb.#{sdb_endpoint}.amazonaws.com"
end

ARGV.options do |opt|
  opt.on('-k', '--access-key=ACCESS_KEY') {|v| access_key_id = v }
  opt.on('-s', '--secret-key=SECRET_KEY') {|v| secret_access_key = v }
  opt.on('-e', '--endpoint=ENDPOINT') {|v| sdb_endpoint = v }
  opt.parse!

  unless access_key_id and secret_access_key and sdb_endpoint
    puts opt.help
    exit 1
  end
end

$runner = SimpleDB::Runner.new(access_key_id, secret_access_key, sdb_endpoint)

def output_error(msg)
  $stderr.puts "ERROR: #{msg}\n\n"
end

def execute(src)
  ss = StringScanner.new(src.dup)

  while query = ss.scan_until(/(?:;|\\G)/i)
    src.replace(ss.rest.strip)
    query.strip!

    if query =~ /\s*\\G\Z/i
      query = query.sub(/\s*\\G\Z/i, '')
      inline = false
    else
      query = query.strip.sub(/\s*;\Z/, '')
      inline = true
    end

    if query.empty?
      output_error('No query specified')
      next
    end

    out = $runner.execute(query, inline)

    if out
      out = YAML.dump(out)
      out << "\n" unless out =~ /\n\n\Z/
      puts out
    end
  end

  ss.rest.strip
end

unless $stdin.tty?
  src = $stdin.read.strip

  unless src =~ /\s*(?:;|\\G)\Z/i
    src << ';'
  end

  begin
    execute(src)
    exit 0
  rescue Racc::ParseError
    output_error 'Parse error'
    exit 1
  rescue => e
    output_error e.message.strip
    exit 1
  end
end

def help
  <<-EOS
SHOW domains
  displays a domain list

CREATE domain domain_name
  creates a domain

DROP DOMAIN domain_name
  deletes a domain

GET [attr_list] FROM domain_name WHERE itemName = '...'
  gets the attribute of an item

INSERT INTO domain_name (itemName, attr1, ...) values ('name', 'val1', ...)
  creates an item

UPDATE domain_name set attr1 = 'val1', ... where itemName = '...'
  updates an item

DELETE [attr1, ...] FROM domain_name itemName = '...'
  deletes the attribute of an item or an item

SELECT output_list FROM domain_name [where expression] [sort_instructions] [limit limit]
  queries using the SELECT statement

    EOS
end

if File.exist?(HISTORY_FILE)
  open(HISTORY_FILE) do |f|
    f.each_line do |line|
      line = line.strip
      Readline::HISTORY.push(line) unless line.empty?
    end
  end
end

at_exit do
  unless Readline::HISTORY.empty?
    open(HISTORY_FILE, 'wb') do |f|
      Readline::HISTORY.each do |line|
        next if /\A\s*\Z/ =~ line
        f.puts line
      end
    end
  end
end

src = ''
region = $runner.region || 'unknown'
prompt1 = "#{region}> "
prompt2 = "#{' ' * (region.length - 1)}-> "
prompt = prompt1

while buf = Readline.readline(prompt, true)
  if /\A\s*\Z/ =~ buf
    Readline::HISTORY.pop
    next
  end

  if src.empty? and buf =~ /\A\.(.+)/
    r = /\A#{Regexp.compile($1.downcase)}/

    if r =~ 'help'
      puts help
    elsif r =~ 'exit' or r =~ 'quit'
      exit
    elsif r =~ 'version'
      puts "sdbcli #{Version}"
    else
      output_error('Unknown command')
    end
  else
    rv = nil

    begin
      src << (' ' + buf)
      execute(src)
    rescue Racc::ParseError
      output_error 'Parse error'
    rescue => e
      output_error e.message.strip
    end

    prompt = src.empty? ? prompt1 : prompt2
  end
end
