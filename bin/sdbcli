#!/usr/bin/env ruby
$LOAD_PATH << File.join(File.expand_path(File.dirname(__FILE__)), '..', 'lib')

Version = '0.3.4'
HISTORY_FILE = File.join((ENV['HOME'] || ENV['USERPROFILE'] || '.'), '.sdbcli_history')
HISTSIZE = 500

require 'rubygems'
require 'sdbcli'

require 'optparse'
require 'readline'
require 'strscan'
require 'syck' if /\A1\.9/ =~ RUBY_VERSION
require 'yaml'

access_key_id     = ENV['AWS_ACCESS_KEY_ID']
secret_access_key = ENV['AWS_SECRET_ACCESS_KEY']
sdb_endpoint      = ENV['SDB_ENDPOINT'] || ENV['REGION_NAME'] || 'sdb.amazonaws.com'
command = nil

ARGV.options do |opt|
  opt.on('-k', '--access-key=ACCESS_KEY') {|v| access_key_id = v }
  opt.on('-s', '--secret-key=SECRET_KEY') {|v| secret_access_key = v }
  opt.on('-r', '--region=REGION') {|v| sdb_endpoint = v }
  opt.on('-e', '--eval=COMMAND') {|v| command = v }
  opt.parse!

  unless access_key_id and secret_access_key and sdb_endpoint
    puts opt.help
    exit 1
  end
end

$runner = SimpleDB::Runner.new(access_key_id, secret_access_key, sdb_endpoint)

def output_error(msg)
  $stderr.puts "# #{msg}\n\n"
end

def execute(src, show_rows = false)
  ss = StringScanner.new(src.dup)

  while query = ss.scan_until(/(?:;|\\G)/i)
    src.replace(ss.rest.strip)
    query.strip!

    if query =~ /\s*\\G\Z/i
      query = query.sub(/\s*\\G\Z/i, '')
      inline = false
    else
      query = query.strip.sub(/\s*;\Z/, '')
      inline = true
    end

    if query.empty?
      output_error('No query specified')
      next
    end

    out = $runner.execute(query, inline)

    if out
      str = YAML.dump(out).sub(/(?:\r\n|\r|\n)*\Z/, "\n")

      if show_rows and out.kind_of?(Array)
        str << "# #{out.length} rows in set\n"
      end

      str << "\n"
      puts str
    end
  end

  ss.rest.strip
end

if not $stdin.tty? or command
  src = command || $stdin.read.strip

  unless src =~ /\s*(?:;|\\G)\Z/i
    src << ';'
  end

  begin
    execute(src)
    exit 0
  rescue => e
    output_error e.message.strip
    exit 1
  end
end

def help
  <<-EOS
SHOW DOMAINS
  displays a domain list

SHOW REGIONS
  displays a region list

CREATE domain domain_name
  creates a domain

DROP DOMAIN domain_name
  deletes a domain

GET [attr_list] FROM domain_name WHERE itemName = '...'
  gets the attribute of an item

INSERT INTO domain_name (itemName, attr1, ...) values ('name', 'val1', ...)
  creates an item

UPDATE domain_name set attr1 = 'val1', ... where itemName = '...'
  updates an item

DELETE [attr1, ...] FROM domain_name itemName = '...'
  deletes the attribute of an item or an item

SELECT output_list FROM domain_name [where expression] [sort_instructions] [limit limit]
  queries using the SELECT statement

DESC domain_name
  displays information about the domain

USE region_or_endpoint
  changes an endpoint

    EOS
end

if File.exist?(HISTORY_FILE)
  open(HISTORY_FILE) do |f|
    f.each_line do |line|
      line = line.strip
      Readline::HISTORY.push(line) unless line.empty?
    end
  end
end

at_exit do
  unless Readline::HISTORY.empty?
    open(HISTORY_FILE, 'wb') do |f|
      Readline::HISTORY.to_a.slice(-(Readline::HISTORY.length < HISTSIZE ? Readline::HISTORY.length : HISTSIZE)..-1).each do |line|
        next if /\A\s*\Z/ =~ line
        f.puts line
      end
    end
  end
end

src = ''
prompt1 = lambda { "#{$runner.region || 'unknown'}> " }
prompt2 = lambda { "#{' ' * (($runner.region || 'unknown').length - 1)}-> " }
prompt = prompt1.call

while buf = Readline.readline(prompt, true)
  if /\A\s*\Z/ =~ buf
    Readline::HISTORY.pop
    next
  end

  if src.empty? and buf =~ /\A\.(.+)/
    r = /\A#{Regexp.compile($1.downcase)}/

    if r =~ 'help'
      puts help
    elsif r =~ 'exit' or r =~ 'quit'
      exit
    elsif r =~ 'version'
      puts "sdbcli #{Version}"
    else
      output_error('Unknown command')
    end
  else
    rv = nil

    begin
      src << (' ' + buf)
      execute(src, true)
    rescue => e
      output_error e.message.strip
    end

    prompt = src.empty? ? prompt1.call : prompt2.call
  end
end
